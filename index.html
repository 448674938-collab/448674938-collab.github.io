local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local uiEvent = ReplicatedStorage:WaitForChild("UINotify")
local sprintEvent = ReplicatedStorage:WaitForChild("SprintEvent")

local blackScreenGui = playerGui:WaitForChild("BlackScreen")
local blackMainFrame = blackScreenGui:WaitForChild("MainFrame")

local focusScreenGui = playerGui:WaitForChild("FocusScreen")
local focusTop = focusScreenGui:WaitForChild("Top")
local focusDown = focusScreenGui:WaitForChild("Down")

local textScreenGui = playerGui:WaitForChild("TextScreen")
local textMainFrame = textScreenGui:WaitForChild("MainFrame")
local textLabel = textMainFrame:WaitForChild("Text")

local chatScreen = playerGui:WaitForChild("ChatScreen")
local chatMainFrame = chatScreen:WaitForChild("MainFrame")
local chatText = chatMainFrame:WaitForChild("TextHere")
local charNameLabel = chatMainFrame:WaitForChild("CharacterName")
local charViewport = chatMainFrame:WaitForChild("CharacterViewport")

local hungerGui = playerGui:WaitForChild("Hunger")
local hungerBack = hungerGui:WaitForChild("MainFrame"):WaitForChild("Back")
local hungerCanvas = hungerBack:WaitForChild("HungerCanvas")
local hungerBar = hungerCanvas:WaitForChild("Bar")
local thirstCanvas = hungerBack:WaitForChild("ThirstyCanvas")
local thirstBar = thirstCanvas:WaitForChild("Bar")

local staminaGui = playerGui:WaitForChild("Stamina")
local staminaBack = staminaGui:WaitForChild("MainFrame"):WaitForChild("Back")
local staminaCanvas = staminaBack:WaitForChild("StaminaCanvas")
local staminaBar = staminaCanvas:WaitForChild("Bar")


local typewriterToken = 0
local textHideToken = 0
local chatToken = 0
local sprinting = false

local MAX_BAR_WIDTH = 0.92962

local meterGui = playerGui:WaitForChild("MeterScreen")
local meterLabel = meterGui:WaitForChild("MainFrame"):WaitForChild("Stamina")

local function getMeters()
	local char = player.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then return 0 end
	local startZ = player:GetAttribute("StartZ")
	if not startZ then
		player:SetAttribute("StartZ", hrp.Position.Z)
		startZ = hrp.Position.Z
	end
	return math.max(0, math.floor((startZ - hrp.Position.Z) + 0.5))
end

local function formatMeters(m)
	m = math.clamp(m or 0, 0, 9999)
	return string.format("Meters: %04d", m)
end

local function createSpring(damping, speed)
	return {
		value = 1,
		velocity = 0,
		damping = damping or 15,
		speed = speed or 60,
		update = function(self, dt, target)
			local delta = target - self.value
			local acceleration = delta * self.speed - self.velocity * self.damping
			self.velocity = self.velocity + acceleration * dt
			self.value = self.value + self.velocity * dt
			return self.value
		end
	}
end

local hungerSpring = createSpring(18, 70)
local thirstSpring = createSpring(18, 70)
local staminaSpring = createSpring(22, 85)

local target = {hunger = 1, thirst = 1, stamina = 1}

local function setTargets(h, t, s)
	if h ~= nil then target.hunger = math.clamp(h, 0, 1) end
	if t ~= nil then target.thirst = math.clamp(t, 0, 1) end
	if s ~= nil then target.stamina = math.clamp(s, 0, 1) end
end

local function updateBars(dt)
	local h = hungerSpring:update(dt, target.hunger)
	local th = thirstSpring:update(dt, target.thirst)
	local st = staminaSpring:update(dt, target.stamina)

	hungerBar.Size = UDim2.new(math.clamp(h, 0, 1) * MAX_BAR_WIDTH, 0, hungerBar.Size.Y.Scale, 0)
	thirstBar.Size = UDim2.new(math.clamp(th, 0, 1) * MAX_BAR_WIDTH, 0, thirstBar.Size.Y.Scale, 0)
	staminaBar.Size = UDim2.new(math.clamp(st, 0, 1) * MAX_BAR_WIDTH, 0, staminaBar.Size.Y.Scale, 0)

	if h <= 0 then
		hungerBar.BackgroundColor3 = Color3.fromRGB(236, 66, 66)
	elseif h <= 0.2 then
		hungerBar.BackgroundColor3 = Color3.fromRGB(255, 160, 100)
	else
		hungerBar.BackgroundColor3 = Color3.fromRGB(255, 237, 191)
	end

	if th <= 0 then
		thirstBar.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
	elseif th <= 0.2 then
		thirstBar.BackgroundColor3 = Color3.fromRGB(130, 180, 255)
	else
		thirstBar.BackgroundColor3 = Color3.fromRGB(156, 224, 255)
	end
end

RunService.RenderStepped:Connect(function(dt)
	updateBars(dt)
	meterLabel.Text = formatMeters(getMeters())
end)

local function resetAllBars()
	setTargets(1, 1, 1)
	hungerSpring.value, thirstSpring.value, staminaSpring.value = 1, 1, 1
	hungerSpring.velocity, thirstSpring.velocity, staminaSpring.velocity = 0, 0, 0
end

local function blackscreenShow()
	blackMainFrame.BackgroundTransparency = 0
	blackScreenGui.Enabled = true
end

local function blackscreenHide()
	blackScreenGui.Enabled = false
end

local function blackscreenFadeIn(duration)
	blackMainFrame.BackgroundTransparency = 1
	blackScreenGui.Enabled = true
	TweenService:Create(blackMainFrame, TweenInfo.new(duration or 1), {BackgroundTransparency = 0}):Play()
end

local function blackscreenFadeOut(duration)
	blackMainFrame.BackgroundTransparency = 0
	blackScreenGui.Enabled = true
	local t = TweenService:Create(blackMainFrame, TweenInfo.new(duration or 1), {BackgroundTransparency = 1})
	t:Play()
	t.Completed:Connect(function()
		blackScreenGui.Enabled = false
	end)
end

local FOCUS_TOP_HIDDEN = UDim2.new(0.5, 0, -0.1, 0)
local FOCUS_TOP_SHOWN = UDim2.new(0.5, 0, 0.0871, 0)
local FOCUS_DOWN_HIDDEN = UDim2.new(0.5, 0, 1.1, 0)
local FOCUS_DOWN_SHOWN = UDim2.new(0.5, 0, 0.92421, 0)

local function focusShow()
	focusTop.Position = FOCUS_TOP_SHOWN
	focusDown.Position = FOCUS_DOWN_SHOWN
	focusScreenGui.Enabled = true
end

local function focusHide()
	focusScreenGui.Enabled = false
end

local function focusAnimateIn(duration)
	duration = duration or 0.6
	focusTop.Position = FOCUS_TOP_HIDDEN
	focusDown.Position = FOCUS_DOWN_HIDDEN
	focusScreenGui.Enabled = true
	TweenService:Create(focusTop, TweenInfo.new(duration, Enum.EasingStyle.Quart), {Position = FOCUS_TOP_SHOWN}):Play()
	TweenService:Create(focusDown, TweenInfo.new(duration, Enum.EasingStyle.Quart), {Position = FOCUS_DOWN_SHOWN}):Play()
end

local function focusAnimateOut(duration)
	duration = duration or 0.6
	local t1 = TweenService:Create(focusTop, TweenInfo.new(duration, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {Position = FOCUS_TOP_HIDDEN})
	local t2 = TweenService:Create(focusDown, TweenInfo.new(duration, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {Position = FOCUS_DOWN_HIDDEN})
	t1:Play()
	t2:Play()
	t1.Completed:Connect(function()
		focusScreenGui.Enabled = false
	end)
end

local function textHide()
	typewriterToken += 1
	textHideToken += 1
	local my = textHideToken
	local t = TweenService:Create(textLabel, TweenInfo.new(0.3), {TextTransparency = 1, TextStrokeTransparency = 1})
	t:Play()
	t.Completed:Connect(function()
		if textHideToken ~= my then return end
		textScreenGui.Enabled = false
		textLabel.Text = ""
	end)
end

local function textSet(text, duration)
	typewriterToken += 1
	textHideToken += 1
	textLabel.Text = text or ""
	textLabel.TextTransparency = 0
	textLabel.TextStrokeTransparency = 0.9
	textScreenGui.Enabled = true
	if duration and duration > 0 then
		local my = textHideToken
		task.delay(duration, function()
			if textHideToken ~= my then return end
			textHide()
		end)
	end
end

local function utf8Len(s)
	local ok, n = pcall(function() return utf8.len(s) end)
	if ok and n then return n end
	local c, i = 0, 1
	while i <= #s do
		local b = s:byte(i)
		if b >= 240 then i += 4
		elseif b >= 224 then i += 3
		elseif b >= 192 then i += 2
		else i += 1 end
		c += 1
	end
	return c
end

local function utf8Sub(s, n)
	local ok, sub = pcall(function() return utf8.sub(s, 1, n) end)
	if ok and sub then return sub end
	local out, count, i = {}, 0, 1
	while i <= #s and count < n do
		local b = s:byte(i)
		local bytes = (b >= 240 and 4) or (b >= 224 and 3) or (b >= 192 and 2) or 1
		out[#out+1] = s:sub(i, i + bytes - 1)
		i += bytes
		count += 1
	end
	return table.concat(out)
end

local function textTypewriter(text, charDelay, duration)
	text = text or ""
	charDelay = charDelay or 0.04
	typewriterToken += 1
	textHideToken += 1
	local myTok = typewriterToken
	textLabel.Text = ""
	textLabel.TextTransparency = 0
	textLabel.TextStrokeTransparency = 0.9
	textScreenGui.Enabled = true
	task.spawn(function()
		local total = utf8Len(text)
		for i = 1, total do
			if typewriterToken ~= myTok then return end
			textLabel.Text = utf8Sub(text, i)
			task.wait(charDelay)
		end
		if duration and duration > 0 then
			local my = textHideToken
			task.delay(duration, function()
				if textHideToken ~= my then return end
				textHide()
			end)
		end
	end)
end

local function chatTypewriter(text, label, charDelay, myTok)
	local total = utf8Len(text)
	for i = 1, total do
		if chatToken ~= myTok then return end
		label.Text = utf8Sub(text, i)
		task.wait(charDelay or 0.03)
	end
end

local function setupCharacterViewport(model)
	if not model or not model:IsA("Model") then return end
	for _, child in ipairs(charViewport:GetChildren()) do
		child:Destroy()
	end
	local clone = model:Clone()
	for _, part in ipairs(clone:GetDescendants()) do
		if part:IsA("BasePart") then
			part.LocalTransparencyModifier = 0
		end
	end
	clone.PrimaryPart = clone:FindFirstChild("HumanoidRootPart") or clone:FindFirstChildWhichIsA("BasePart")
	if clone.PrimaryPart then
		clone:PivotTo(CFrame.new(0, 0, 0))
		clone.Parent = charViewport
		local cam = Instance.new("Camera")
		cam.CFrame = CFrame.new(0, 3, 8) * CFrame.Angles(0, math.pi, 0)
		cam.FieldOfView = 30
		charViewport.CurrentCamera = cam
		cam.Parent = charViewport
	end
end

local function chatSet(characterName, text, model, duration)
	chatToken += 1
	local myTok = chatToken

	charNameLabel.Text = characterName or "Unknown"
	chatText.Text = ""
	chatText.TextTransparency = 0
	chatText.TextStrokeTransparency = 0.9
	charNameLabel.TextTransparency = 0
	charNameLabel.TextStrokeTransparency = 0.9

	if model then
		setupCharacterViewport(model)
		charViewport.Visible = true
	else
		charViewport.Visible = false
	end

	local originalPos = chatMainFrame.Position
	chatMainFrame.Position = UDim2.new(originalPos.X.Scale, originalPos.X.Offset, 2, 0)
	chatScreen.Enabled = true

	local slideIn = TweenService:Create(chatMainFrame, TweenInfo.new(0.55, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {
		Position = originalPos
	})
	slideIn:Play()

	task.spawn(function()
		chatTypewriter(text or "", chatText, 0.03, myTok)
		if chatToken ~= myTok then return end
		if duration and duration > 0 then
			task.wait(duration)
			if chatToken ~= myTok then return end

			local slideOut = TweenService:Create(chatMainFrame, TweenInfo.new(0.55, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
				Position = UDim2.new(originalPos.X.Scale, originalPos.X.Offset, 2, 0)
			})
			slideOut:Play()

			slideOut.Completed:Wait()
			if chatToken ~= myTok then return end

			chatScreen.Enabled = false
			chatMainFrame.Position = originalPos
			chatText.Text = ""
			charNameLabel.Text = ""
		end
	end)
end

local function chatHide()
	chatToken += 1

	local originalPos = chatMainFrame.Position
	local slideOut = TweenService:Create(chatMainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
		Position = UDim2.new(originalPos.X.Scale, originalPos.X.Offset, 2, 0)
	})
	slideOut:Play()

	slideOut.Completed:Wait()

	chatScreen.Enabled = false
	chatMainFrame.Position = originalPos
	chatText.Text = ""
	charNameLabel.Text = ""

	for _, child in ipairs(charViewport:GetChildren()) do
		child:Destroy()
	end
end

local function staminaFlash()
	local original = staminaBar.BackgroundColor3
	local flashTween = TweenService:Create(staminaBar, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(255, 70, 70)})
	flashTween:Play()
	flashTween.Completed:Connect(function()
		TweenService:Create(staminaBar, TweenInfo.new(0.2), {BackgroundColor3 = original}):Play()
	end)
end

local actionHandlers = {
	blackscreen_show = function() blackscreenShow() end,
	blackscreen_hide = function() blackscreenHide() end,
	blackscreen_fade_in = function(data) blackscreenFadeIn(data and data.duration) end,
	blackscreen_fade_out = function(data) blackscreenFadeOut(data and data.duration) end,
	focus_show = function() focusShow() end,
	focus_hide = function() focusHide() end,
	focus_animate_in = function(data) focusAnimateIn(data and data.duration) end,
	focus_animate_out = function(data) focusAnimateOut(data and data.duration) end,
	text_show = function() textScreenGui.Enabled = true end,
	text_hide = function() textHide() end,
	text_set = function(data) textSet(data and data.text, data and data.duration) end,
	text_typewriter = function(data) textTypewriter(data and data.text, data and data.charDelay, data and data.duration) end,
	hunger_set = function(data) setTargets(data and data.fraction, nil, nil) end,
	thirst_set = function(data) setTargets(nil, data and data.fraction, nil) end,
	stamina_set = function(data) setTargets(nil, nil, data and data.fraction) end,
	stamina_flash = function() staminaFlash() end,
	chat_show = function() chatScreen.Enabled = true end,
	chat_hide = function() chatHide() end,
	chat_set = function(data) chatSet(data.characterName, data.text, data.model, data.duration) end,
}

uiEvent.OnClientEvent:Connect(function(action, data)
	local handler = actionHandlers[action]
	if handler then handler(data) end
end)

player.CharacterAdded:Connect(function()
	task.wait(0.1)
	resetAllBars()
	textHide()
	chatHide()
	meterLabel.Text = formatMeters(0)
end)

resetAllBars()

local sprintSeq = 0
local function setSprint(state)
	if sprinting == state then return end
	sprinting = state
	sprintSeq += 1
	local my = sprintSeq
	task.defer(function()
		if sprintSeq ~= my then return end
		sprintEvent:FireServer(state)
	end)
end

UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
		setSprint(true)
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
		setSprint(false)
	end
end)

local function bindSprintButton(btn)
	if not btn or not btn:IsA("GuiButton") then return end

	btn.Active = true
	btn.AutoButtonColor = true

	local down = false

	local function setDown(v)
		if down == v then return end
		down = v
		setSprint(v)
	end

	btn.MouseButton1Down:Connect(function()
		setDown(true)
	end)

	btn.MouseButton1Up:Connect(function()
		setDown(false)
	end)

	btn.MouseLeave:Connect(function()
		setDown(false)
	end)

	btn.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			setDown(true)
		end
	end)

	btn.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			setDown(false)
		end
	end)
end

task.defer(function()
	local pg = player:WaitForChild("PlayerGui")
	local MobileGUI = pg:WaitForChild("MobileGUI", 10)
	if not MobileGUI then return end
	local sprintButton = MobileGUI:WaitForChild("SprintButton", 10)
	if not sprintButton then return end
	bindSprintButton(sprintButton)
end)
